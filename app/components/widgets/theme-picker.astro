---
import { Icon } from "astro-icon/components";

import type { HTMLAttributes } from "astro/types";

type Props = HTMLAttributes<"button">;
---

<theme-picker class="contents">
  <button
    type="button"
    title="Toggle Theme"
    class:list={[
      "group relative flex items-center p-3 text-2xl",
      "text-gray-900 dark:text-gray-200",
      "hover:text-gray-200 dark:hover:text-gray-900",
      "hover:bg-gray-900 dark:hover:bg-gray-200",
      "focus:text-gray-200 dark:focus:text-gray-900",
      "focus:bg-gray-900 dark:focus:bg-gray-200",
      Astro.props.class,
    ]}
  >
    <span class="sr-only">Toggle theme</span>
    <Icon
      data-id="x-light"
      name="uil:moon"
      role="presentation"
      class="text-inherit data-[hidden=true]:hidden"
      data-hidden="false"
    />
    <Icon
      data-id="x-dark"
      name="uil:sun"
      role="presentation"
      class="text-inherit data-[hidden=true]:hidden"
      data-hidden="false"
    />
    <Icon
      data-id="x-system"
      name="lucide:monitor-cog"
      role="presentation"
      class="text-inherit data-[hidden=true]:hidden"
      data-hidden="false"
    />
  </button>
</theme-picker>

{/* Inlined to avoid FOUC. Uses global scope from `theme-provider.astro` */}
<script is:inline>
  globalThis.Theme.selectThemeIcon();
</script>

<script>
  import { $, createElement } from "@/helpers/dom";
  import { println$ } from "@/helpers/println";

  type Theme = (typeof themes)[number];

  const storageKey = "x-theme";

  const mql = matchMedia("(prefers-color-scheme: light)");

  const themes = ["system", "light", "dark"] as const;
  /** Yields the next theme value, looping back to the first after reaching the end. */
  const themeGenerator = (function* () {
    let index = 0;
    while (true) {
      yield themes[index];
      index = (index + 1) % themes.length;
    }
  })();

  const getPreferredColorScheme = (): Theme => (mql.matches ? "light" : "dark");
  const parseTheme = (theme: unknown): Theme =>
    theme === "light" || theme === "dark" ? theme : "system";

  const loadTheme = (): Theme =>
    parseTheme(typeof localStorage !== "undefined" && localStorage.getItem(storageKey));

  const storeTheme = (theme: Theme) => {
    if (typeof localStorage !== "undefined") {
      localStorage.setItem(storageKey, theme === "light" || theme === "dark" ? theme : "");
    }
  };

  /** Update theme widget, document theme, and local storage state. */
  const onThemeChange = (theme: Theme) => {
    globalThis.Theme.selectThemeIcon(theme);

    const $ = document.documentElement;
    const systemTheme = getPreferredColorScheme();

    $.dataset.colorScheme = theme === "system" ? systemTheme : theme;
    $.dataset.codeTheme =
      theme === "system" ? `github-${systemTheme}-default` : `github-${theme}-default`;

    println$(theme);

    storeTheme(theme);
  };

  // React to changes in system color scheme.
  mql.addEventListener("change", () => {
    if (loadTheme() === "system") onThemeChange("system");
  });

  createElement(
    "theme-picker",
    class ThemePicker extends HTMLElement {
      btn: HTMLButtonElement;
      onClick: (e: PointerEvent) => void;
      constructor() {
        super();
        //@ts-expect-error
        this.btn = $("button", HTMLButtonElement, this);
        this.onClick = this.#handleThemeChange.bind(this);
      }

      connectedCallback() {
        onThemeChange(loadTheme());
        this.btn.addEventListener("click", this.onClick);
      }

      #handleThemeChange(e: PointerEvent) {
        if (e.currentTarget instanceof HTMLButtonElement) {
          onThemeChange(parseTheme(themeGenerator.next().value));
        }
      }

      disconnectedCallback() {
        this.btn.removeEventListener("click", this.onClick);
      }
    },
  );
</script>
