---
// SPDX-License-Identifier: Apache-2.0
import type { HTMLAttributes } from "astro/types";
import { Temporal } from "temporal-polyfill";

type ISO = "full" | "date" | "time" | "month" | "yearless" | "week";
type FormatPreset = "full" | "short" | "long";
type DurationFormat = "short" | "long" | "narrow" | "compact";

interface Props extends Omit<HTMLAttributes<"time">, "datetime"> {
  datetime?: number | string | Date;
  format?: FormatPreset;
  durationFormat?: DurationFormat;
  locale?: Intl.LocalesArgument;
  tz?: string;
  time?: boolean;
  date?: boolean;
  pattern?: string;
  iso?: ISO;
}

const {
  datetime = Temporal.Now.instant().toString(),
  format = "long",
  durationFormat,
  locale = "en-US",
  tz = Temporal.Now.timeZoneId(),
  time = true,
  date = true,
  pattern,
  iso = "full",
  ...attrs
} = Astro.props;

// Check if the input is a duration string
function isDuration(value: string): boolean {
  // ISO 8601 duration format: P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W
  // Also supports shorthand like "2h 30m" or "7d 5h 24m 13s"
  return /^P[\dYMWDTHS.,]+$/i.test(value) || /^\d+\s*[wdhms]/.test(value);
}

// Parse duration strings (both ISO 8601 and shorthand formats)
function parseDuration(value: string): Temporal.Duration {
  // If it's ISO 8601 format, use Temporal directly
  if (/^P/i.test(value)) {
    try {
      return Temporal.Duration.from(value);
    } catch (e) {
      throw new Error(`Invalid ISO 8601 duration: ${value}`);
    }
  }

  // Parse shorthand format like "2h 30m" or "7d 5h 24m 13s"
  const parts: Record<string, number> = {};
  const regex = /(\d+(?:\.\d+)?)\s*([wdhms])/gi;
  let match;
  let hasMatch = false;

  while ((match = regex.exec(value)) !== null) {
    hasMatch = true;
    let [, num = "", unit = ""] = match;
    unit = unit.toLowerCase();
    switch (unit) {
      case "w":
        parts.weeks = parseFloat(num);
        break;
      case "d":
        parts.days = parseFloat(num);
        break;
      case "h":
        parts.hours = parseFloat(num);
        break;
      case "m":
        parts.minutes = parseFloat(num);
        break;
      case "s":
        parts.seconds = parseFloat(num);
        break;
    }
  }

  if (!hasMatch) {
    throw new Error(`Invalid duration format: ${value}`);
  }

  return Temporal.Duration.from(parts);
}

// Format duration for display
function formatDuration(
  duration: Temporal.Duration,
  locales: Intl.LocalesArgument,
  format: DurationFormat = "short",
): string {
  // Map our format types to Intl.DurationFormat styles
  const styles: Record<Exclude<DurationFormat, "compact">, Intl.DurationFormatStyle> = {
    short: "short",
    long: "long",
    narrow: "narrow",
  };

  if (format === "compact") {
    // For compact mode, manually limit to 2 most significant units
    const total = duration.total({ unit: "second" });
    let compact: Temporal.Duration;

    if (duration.years || duration.months) {
      compact = Temporal.Duration.from({
        years: duration.years,
        months: duration.months,
      });
    } else if (duration.weeks || duration.days) {
      compact = Temporal.Duration.from({
        weeks: duration.weeks,
        days: duration.days,
      });
    } else if (duration.hours || duration.minutes) {
      compact = Temporal.Duration.from({
        hours: duration.hours,
        minutes: duration.minutes,
      });
    } else {
      compact = Temporal.Duration.from({
        seconds: duration.seconds,
        milliseconds: duration.milliseconds,
      });
    }

    // Use short style for compact
    return new Intl.DurationFormat(locales, { style: "short" }).format(compact);
  }

  // Use native Intl.DurationFormat for other styles
  return new Intl.DurationFormat(locales, { style: styles[format] }).format(duration);
}

// Convert duration to ISO 8601 format for datetime attribute
function durationToISO(duration: Temporal.Duration): string {
  return duration.toString();
}

function createInstant(value?: number | string | Date) {
  if (!value) return Temporal.Now.instant();
  if (typeof value === "string") return Temporal.Instant.from(value);
  if (value instanceof Date) return value.toTemporalInstant();
  return Temporal.Instant.fromEpochMilliseconds(value);
}

function formatPreset(
  zdt: Temporal.ZonedDateTime,
  preset: FormatPreset,
  date: boolean,
  time: boolean,
  locales: Intl.LocalesArgument,
) {
  const opts: Intl.DateTimeFormatOptions = {};

  if (date) {
    opts.year = preset === "short" ? "2-digit" : "numeric";
    opts.month = preset === "full" ? "long" : "2-digit";
    opts.day = "2-digit";
  }

  if (time) {
    opts.hour = "2-digit";
    opts.minute = "2-digit";
    if (preset === "full") opts.second = "2-digit";
  }

  return zdt.toLocaleString(locales, opts);
}

const pad = (n = 0, maxLength = 2) => String(n).padStart(maxLength, "0");

function formatPattern(zdt: Temporal.ZonedDateTime, pat: string) {
  return pat
    .replace(/yyyy/g, String(zdt.year))
    .replace(/MM/g, pad(zdt.month))
    .replace(/dd/g, pad(zdt.day))
    .replace(/HH/g, pad(zdt.hour))
    .replace(/mm/g, pad(zdt.minute))
    .replace(/ss/g, pad(zdt.second));
}

function buildDatetime(zdt: Temporal.ZonedDateTime, type: ISO) {
  const y = pad(zdt.year, 4);
  const m = pad(zdt.month);
  const d = pad(zdt.day);
  const h = pad(zdt.hour);
  const min = pad(zdt.minute);
  const s = pad(zdt.second);
  const tz = zdt.offset;

  const formats = {
    full: `${y}-${m}-${d}T${h}:${min}:${s}${tz}`,
    date: `${y}-${m}-${d}`,
    time: `${h}:${min}`,
    month: `${y}-${m}`,
    yearless: `${m}-${d}`,
    week: `${y}-W${pad(zdt.weekOfYear)}`,
  } satisfies Record<ISO, string>;

  return formats[type];
}

// Handle both durations and instants
let output: string;
let instant: string;

if (typeof datetime === "string" && isDuration(datetime)) {
  // Handle duration
  const duration = parseDuration(datetime);
  // Use durationFormat if provided, otherwise fall back to format prop
  const durFmt = durationFormat || (format === "full" ? "short" : format === "short" ? "compact" : "short");
  output = formatDuration(duration, locale, durFmt);
  instant = durationToISO(duration);
} else {
  // Handle instant/date/time
  const zdt = createInstant(datetime).toZonedDateTimeISO(tz);
  output = pattern ? formatPattern(zdt, pattern) : formatPreset(zdt, format, date, time, locale);
  instant = buildDatetime(zdt, iso);
}
---

<time datetime={instant} {...attrs}>
  <slot>{output}</slot>
</time>
